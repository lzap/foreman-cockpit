diff --git a/lib/smart_proxy_remote_execution_ssh.rb b/lib/smart_proxy_remote_execution_ssh.rb
index ee048ba..8b76ab0 100644
--- a/lib/smart_proxy_remote_execution_ssh.rb
+++ b/lib/smart_proxy_remote_execution_ssh.rb
@@ -1,5 +1,6 @@
 require 'smart_proxy_remote_execution_ssh/version'
 require 'smart_proxy_dynflow'
+require 'smart_proxy_remote_execution_ssh/webrick_ext'
 require 'smart_proxy_remote_execution_ssh/plugin'

 module Proxy::RemoteExecution
diff --git a/lib/smart_proxy_remote_execution_ssh/api.rb b/lib/smart_proxy_remote_execution_ssh/api.rb
index 9211f19..f8d294a 100644
--- a/lib/smart_proxy_remote_execution_ssh/api.rb
+++ b/lib/smart_proxy_remote_execution_ssh/api.rb
@@ -1,9 +1,208 @@
+require 'net/ssh'
+
+# When hijacking the socket of a TLS connection, we get a
+# OpenSSL::SSL::SSLSocket or Puma::MiniSSL::Socket, which don't behave
+# the same as real IO::Sockets.  We need to add recv and send for the
+# benefit of the Net::SSH::BufferedIo mixin, and closed? for our own
+# convenience.
+
+module Puma
+  module MiniSSL
+    class Socket
+      def closed?
+        @socket.closed?
+      end
+      def recv(n)
+        readpartial(n)
+      end
+      def send(mesg, flags)
+        write(mesg)
+      end
+    end
+  end
+end
+
+module OpenSSL
+  module SSL
+    class SSLSocket
+      def recv(n)
+        res = ""
+        begin
+          # To drain a SSLSocket before we can go back to the event
+          # loop, we need to repeatedly call read_nonblock; a single
+          # call is not enough.
+          while true
+            res += read_nonblock(n)
+          end
+        rescue IO::WaitReadable
+          # Sometimes there is no payload after reading everything
+          # from the underlying socket, but a empty string is treated
+          # as EOF by Net::SSH. So we block a bit until we have
+          # something to return.
+          if res == ""
+            IO.select([io])
+            retry
+          else
+            res
+          end
+        rescue IO::WaitWritable
+          # A renegotiation is happening, let it proceed.
+          IO.select(nil, [io])
+          retry
+        end
+      end
+
+      def send(mesg, flags)
+        begin
+          write_nonblock(mesg)
+        rescue IO::WaitWritable
+          0
+        rescue IO::WaitReadable
+          IO.select([io])
+          retry
+        end
+      end
+    end
+  end
+end
+
 module Proxy::RemoteExecution
   module Ssh
     class Api < ::Sinatra::Base
       get "/pubkey" do
         File.read(Ssh.public_key_file)
       end
+
+      post "/session" do
+        if env["HTTP_CONNECTION"] != "upgrade" or env["HTTP_UPGRADE"] != "raw"
+          return [ 400, "Invalid request: /ssh/session requires connection upgrade to 'raw'" ]
+        end
+
+        params = MultiJson.load(env["rack.input"].read)
+        key_file = Proxy::RemoteExecution::Ssh.private_key_file
+
+        methods = %w(publickey)
+        methods.unshift('password') if params["ssh_password"]
+
+        ssh_options = { }
+        ssh_options[:port] = params["ssh_port"] if params["ssh_port"]
+        ssh_options[:keys] = [ key_file ] if key_file
+        ssh_options[:password] = params["ssh_password"] if params["ssh_password"]
+        ssh_options[:passphrase] = params[:ssh_key_passphrase] if params[:ssh_key_passphrase]
+        ssh_options[:keys_only] = true
+        ssh_options[:auth_methods] = methods
+        ssh_options[:verify_host_key] = true
+        ssh_options[:number_of_password_prompts] = 1
+
+        socket = nil
+        if env['WEBRICK_SOCKET']
+          socket = env['WEBRICK_SOCKET']
+        elsif env['rack.hijack?']
+          begin
+            env['rack.hijack'].call
+          rescue NotImplementedError
+          end
+          socket = env['rack.hijack_io']
+        end
+        if !socket
+          return [ 501, "Internal error: request hijacking not available" ]
+        end
+
+        ssh_on_socket(socket, params["command"], params["ssh_user"], params["hostname"], ssh_options)
+        101
+      end
+
+      def ssh_on_socket(socket, command, ssh_user, host, ssh_options)
+        started = false
+        err_buf = ""
+        socket.extend(Net::SSH::BufferedIo)
+
+        send_start = -> {
+          if !started
+            started = true
+            socket.enqueue("Status: 101\r\n")
+            socket.enqueue("Connection: upgrade\r\n")
+            socket.enqueue("Upgrade: raw\r\n")
+            socket.enqueue("\r\n")
+          end
+        }
+
+        send_error = -> (code, msg) {
+          socket.enqueue("Status: #{code}\r\n")
+          socket.enqueue("Connection: close\r\n")
+          socket.enqueue("\r\n")
+          socket.enqueue(msg)
+        }
+
+        begin
+          Net::SSH.start(host, ssh_user, ssh_options) do |ssh|
+            channel = ssh.open_channel do |ch|
+              ch.exec(command) do |ch, success|
+                raise "could not execute command" unless success
+
+                ssh.listen_to(socket)
+
+                ch.on_process do
+                  if socket.available > 0
+                    ch.send_data(socket.read_available)
+                  end
+                  if socket.closed?
+                    ch.close
+                  end
+                end
+
+                ch.on_data do |ch2, data|
+                  send_start.call
+                  socket.enqueue(data)
+                end
+
+                ch.on_request('exit-status') do |ch, data|
+                  code = data.read_long
+                  if code == 0
+                    send_start.call
+                  end
+                  err_buf += "Process exited with code #{code}.\r\n"
+                  ch.close
+                end
+
+                channel.on_request('exit-signal') do |ch, data|
+                  err_buf += "Process was terminated with signal #{data.read_string}.\r\n"
+                  ch.close
+                end
+
+                ch.on_extended_data do |ch2, type, data|
+                  err_buf += data
+                end
+              end
+            end
+
+            channel.wait
+            if !started
+              send_error.call(400, err_buf)
+            end
+          end
+        rescue Net::SSH::AuthenticationFailed => e
+          send_error.call(401, e.message)
+        rescue Errno::EHOSTUNREACH
+          send_error.call(400, "No route to #{host}")
+        rescue SystemCallError => e
+          send_error.call(400, e.message)
+        rescue SocketError => e
+          send_error.call(400, e.message)
+        rescue Exception => e
+          logger.error e.message
+          e.backtrace.each { |line| logger.debug line }
+          send_error.call(500, "Internal error") unless started
+        end
+        if not socket.closed?
+          socket.wait_for_pending_sends
+          socket.close
+        end
+      end
+
     end
   end
 end
diff --git a/lib/smart_proxy_remote_execution_ssh/webrick_ext.rb b/lib/smart_proxy_remote_execution_ssh/webrick_ext.rb
new file mode 100644
index 0000000..8ec00c8
--- /dev/null
+++ b/lib/smart_proxy_remote_execution_ssh/webrick_ext.rb
@@ -0,0 +1,11 @@
+module SmartProxyRemoteExecutionSsh
+  module WEBrickExt
+    # An extension to ::WEBrick::HTTPRequest to expost the socket object for highjacking for cockpit
+    module HTTPRequestExt
+      def meta_vars
+        super.merge('WEBRICK_SOCKET' => @socket)
+      end
+    end
+  end
+  ::WEBrick::HTTPRequest.send(:prepend, WEBrickExt::HTTPRequestExt)
+end
