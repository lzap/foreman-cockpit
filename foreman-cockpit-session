#!/usr/bin/env ruby

require "json"
require "net/https"

# Cockpit protocol, encoding and decoding of control messages.

def send_control(msg)
  text = JSON.dump(msg)
  $stdout.write("#{text.length+1}\n\n#{text}")
  $stdout.flush
end

def read_control
  size = $stdin.readline.chomp.to_i
  raise ArgumentError, "Invalid frame: invalid size" if size.zero?
  data = $stdin.read(size)
  raise ArgumentError, "Invalid frame: too short" if data == nil || data.length < size
  JSON.parse(data)
end

# Specific control messages

def send_auth_challenge(challenge)
  send_control({ "command" => "authorize",
                 "cookie" => "1234", # must be present, but value doesn't matter
                 "challenge" => challenge
               })
end

def send_auth_response(response)
  send_control({ "command" => "authorize",
                 "response" => response
               })
end

def read_auth_reply
  cmd = read_control()
  response = cmd["response"]
  raise ArgumentError, "Did not receive a valid authorize command" if cmd["command"] != "authorize" || !response
  response
end

def exit_with_problem(problem, message, auth_methods)
  send_control({ "command" => "init",
                 "problem" => problem,
                 "message" => message,
                 "auth-method-results" => auth_methods
               })
  exit 1
end

# Talking to Foreman

def get_token_from_auth_data(auth_data)
  auth_data.split(" ")[1]
end

def foreman_call(path, token)
  foreman = ENV["FOREMAN_URL"] || "https://localhost/"
  uri = URI(foreman + path)
  req = Net::HTTP::Get.new(uri)
  req["Cookie"] = "_session_id=#{token}"
  res = Net::HTTP.start(uri.hostname, uri.port,
                        :use_ssl => uri.scheme == "https", :verify_mode => OpenSSL::SSL::VERIFY_NONE) {
    |http| http.request(req)
  }

  case res.code
  when "200"
    return JSON.parse(res.body)
  when "401"
    exit_with_problem("authentication-failed",
                      "Token was not valid",
                      { "password" => "not-tried", "token" => "denied" })
  when "404"
    return nil
  else
    $stderr.write("Error talking to foreman: #{res.body}\n")
    exit 1
  end
end

# SSH via the smart proxy

def ssh_with_proxy(proxy, params)
  url = URI(proxy["url"])
  raw_sock = TCPSocket.open(url.hostname, url.port)
  if url.scheme == 'https'
    ssl_context = OpenSSL::SSL::SSLContext.new()
    ssl_context.cert = OpenSSL::X509::Certificate.new(proxy["ssl_certificate"])
    ssl_context.key = OpenSSL::PKey.read(proxy["ssl_priv_key"])
    sock = OpenSSL::SSL::SSLSocket.new(raw_sock, ssl_context)
    sock.sync_close = true
    sock.connect
  else
    sock = raw_sock
  end

  data = JSON.dump(params) + "\r\n"
  inp_buf = "POST /ssh/session HTTP/1.1\r\nConnection: upgrade\r\nUpgrade: raw\r\nContent-Length: #{data.length}\r\n\r\n#{data}"
  out_buf = ""

  ws_eof = false
  bridge_eof = false
  expecting_http_header = true

  status = ""

  while true
    readers = [ ]
    writers = [ ]

    readers += [ $stdin ] unless ws_eof
    readers += [ sock ] unless bridge_eof
    writers += [ sock ] unless inp_buf == ""

    if out_buf.length > 0
      if expecting_http_header
        header_end = out_buf.index("\r\n\r\n")
        if header_end
          status_line, headers_text = out_buf[0..header_end].split("\r\n", 2)
          status = status_line.split(" ")[1]
          out_buf = out_buf[header_end+4..-1]
          expecting_http_header = false
          if status != "101"
            m = /^Content-Length:[ \t]*([0-9]+)\r?$/i.match(headers_text)
            if m
              expected_len = m[1].to_i
            else
              expected_len = -1
            end
            while expected_len < 0 || out_buf.length < expected_len
              begin
                out_buf += sock.readpartial(4096)
              rescue EOFError
                break
              end
            end
            if status[0] == "4"
              exit_with_problem("access-denied", out_buf, nil)
            else
              $stderr.write("Error talking to smart proxy: #{out_buf}\n")
              exit 1
            end
          end
        end
      end
      writers += [ $stdout ] unless out_buf == ""
    end

    break if readers.length + writers.length == 0

    r, w, x = IO.select(readers, writers)

    if r.include?(sock)
      begin
        while true
          out_buf += sock.read_nonblock(4096)
        end
      rescue EOFError
        bridge_eof = true
        break if out_buf == ""
      rescue IO::WaitReadable
        # This is fine.
      rescue IO::WaitWritable
        # This might happen with SSL during a renogiation.  Block a
        # bit to get it over with.
        IO.select(nil, [sock])
        retry
      end
    end

    if w.include?(sock)
      begin
        n = sock.write_nonblock(inp_buf)
        inp_buf = inp_buf[n..-1]
        if inp_buf == "" and ws_eof
          raw_sock.close_write()
        end
      rescue IO::WaitWritable
        # This is fine.
      rescue IO::WaitReadable
        # This might happen with SSL during a renogiation.  Block a
        # bit to get it over with.
        IO.select([sock])
        retry
      end
    end

    if r.include?($stdin)
      begin
        inp_buf += $stdin.readpartial(4096)
      rescue EOFError
        ws_eof = true
        raw_sock.close_write() if inp_buf == ""
      end
    end

    if w.include?($stdout)
      n = $stdout.write(out_buf)
      $stdout.flush()
      out_buf = out_buf[n..-1]
      break if out_buf == "" and bridge_eof
    end

  end
end

# Main

host = ARGV[0]

send_auth_challenge("*")
token = get_token_from_auth_data(read_auth_reply())
params = foreman_call("cockpit/host_ssh_params/#{host}", token)

exit_with_problem("access-denied", "Host #{host} is not known", nil) unless params

params["command"] = "cockpit-bridge"
case params["proxy"]
when "not_available"
  exit_with_problem("access-denied", "A proxy is required to reach #{host} but all of them are down", nil)
when "not_defined"
  exit_with_problem("access-denied", "A proxy is required to reach #{host} but none has been configured", nil)
when "direct"
  exit_with_problem("access-denied", "Web console sessions require a proxy but none has been configured", nil)
else
  ssh_with_proxy(params["proxy"], params)
end
